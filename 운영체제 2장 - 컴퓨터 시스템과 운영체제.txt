>>>컴퓨터 하드웨어
 - 하드웨어와 소웨 사이에서 컨트롤러가 관리함

 > 목적에 따라 버스 구분
   - 시스템 버스, I/O 버스

>>> CPU 
 - 32bit 일때 , 0 ~ 2^32-1 번지,     바이트는 4GB
 - CPU는 insturction 을 이용하여 명령을 실행

>>> 프로그램 이 저장되는 위치

 - 힙 : 동적할당 공간
 - 스택 : 매개변수, 지역변수 공간
 - 코드 : 함수같은 코드가 저장되는 공간
 - 데이터 : 글로벌 변수들

 > 스택이 저장되는 위치
    - RAM 에서 각 프로그램의 마지막 영역
    - RAM에서 SP랑은 별개

 > 컨택스트 : 프로그램이 실행 되는 상황
    - 메모리, CPU레지스터 들의 값
  
>>> [운영체제 + 응용프로그램 관계]

1.응용 프로그램이 직접 하드웨어를 다루지 못하게 함
2.응-프가 운영체제의 힘빌려 대신 조작
3.시스템 호출(system call)사용 read_size = read(fd, buffer, size)

>>> [운영체제 + 사용자 관계]
1. 사용자는 응-프를 통해 컴퓨터 사용
2. 하드웨어를 간단히 사용자가 사용하게 해줌
3. 다양한 응-프 제공 (shell) + rinux

>>> [운영체제 + 하드웨어 관계]
1. 하드웨어 제어 - printf("hello") -> 화면에 hello를 출력을 하도록 운영체제를 사용

>>>[운영체제 전체기능]

- 프로세스와 스레드 관리 
-> 저장된 프로그램을 실행하는것을 프로세스라고 명명




>>> [운영체제의 구성 요소와 커널]
-> 사용자 
-> GUI or 응용프로그램 
-> 표준 라이브러리/ 시스템 라이브러리 
표준: printf, scanf 등
시스템 : read같은 기능을 사용하기위해 담아놓은 파일
->시스템 호출 헨들러 
커널: 직접 하드웨어를 읽고쓰는 함수들의 모읍집; 커널 함수들
------------------------------------------------------------------------


> 운영체제 = 커널 + 툴 + 디바이스 드라이버 (마우스, 키보드)

> 커널(kernel)
- 실행을 하는 함수들의 집합
- 부팅후 메모리에 상주하며 , CPU, 캐시, 메모리를 관리

> 커널 인터페이스 : 커널 사용법
- 시스템 호출 (system function call)
1. 커널와 응용프로그램 사이의 인터페이스
2.다양한 시스템 호출 함수 제공 (open(), close())

> 표준라이브러리
	- 응용 프로그램을 쉽게 작성할수 있는 미리작성된 코드




> 커널속 : 인터럽트
	- 커널과 하드웨어 사이의 인터페이스
	- 입출력이 끝났을때 알려줌 - 하드웨어 신호를 CPU에 전달

> 응용프로그램 자원 접근 문제 - 88p
 	- 응-프가 직접 컴퓨터 자원에 접근 시 -> 메모리를 지 맘대로
	
	[해결 방안] 
		1.메모리 공간을 사용자와 커널 공간으로 분리
		2. CPU실행 모드를 사용자, 커널 모드로 분리

> [사용자 공간 크기]
	32비트 windows : 프로그램당 최대 크기 2GB
	주소공간은 커널 + 사용자 공간
	
커널공간은 RAM의 고정된 위치에서 하나의 공간만 가짐

응용프로그램의 확정된 2GB가  메모리 2GB에 저장된다면
한번에 한 프로그램만 실행 가능하지만,
 응-프를 작은 조각만 매핑후 메모리의 여기저기 작게 저장하여 
필요한 부분만 조금씩 저장해, 메모리에 더 많은 응-프를 저장가능.


-------------------------------------------------------------------------
>>> [사용자 모드와 커널모드] : 모드 레지스터 : 1,0
	사용자 모드(1) => (CPU의 커널 공간 접근 , *특권 명령어) 불가
	커널 모드(0)   => (모든 공간접근 쌉가능, 모든명령)
	
	시스템 호출, 인터럽트시만 = (사용자) -> (커널)로 변경

	> *특권 명령어 (커널 모드):
		I/O 명령어 : 하드웨어 제어
		Halt 명령어 : CPU 작동중지-> 유휴
		인터럽트 : CPU가 인터럽트를 할지/말지
		타이머 세팅 : 시분할 시스템, 타이머 세팅
		컨텍스트 : 프로그램 실행중 스위칭
		
	QUIZ - 어떤게 특권명령어?
	1. 사용자모드 -> 커널모드 전환시키는 명령어
		X : 시스템 호출이라서 (유저모드에서 시작임)
	2. 시계 읽기 
		X : 모든 응-프에서 쌉가능
	3. 인터럽트 끄기
		O : 특권 명령어만 가능

	> 커널 모드가 따로 있는이유
		- 커널 공간 보호, 모드는 CPU가 제어
		- 기본적으로 커널 모드의 비중이 큼 (입출력 idle)


커널은 스스로 실행되지 않음
커널은 실행중 X => 시스템 호출하여 코널 코드를 실행 O

-------------------------------------------------------------------------------------------

응용프로그램 

>>> 표준 라이브러리
	- stdio.h 와같이 미리 만들어진 함수를 제공
>>> 시스템 호출 라이브러리
	- 시스템 호출 함수 --> 커널 모드 전환후 커널 함수 실행
	- 커널 API (read , write)
	
>>> [ 시스템 호출 ]
	- 사용자 공간에서 커널 서비스 요청하는 과정
	
	> read(), write() ! *read과정 책에서 확인하기


그냥 fread() 가 read() 보다 더 빠름

-----------------------------------------------------------------------

>>> [ 인터럽트 ]

-하드웨어 인터럽트
-소프트웨어 인터럽트

키보드입력 -> N번 ISR실행 -> 메모리로가 N번 ISR루틴을 찾아감, IDTR 이 재 시작 주소를 알려줌

	> 다중프로그래밍
		- 인터럽드가 없다면 CPU가 I/O를 계속 기다리기 때문에 다른 프로세스를 처리몬함
		
 